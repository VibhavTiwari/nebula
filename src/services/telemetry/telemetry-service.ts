/**
 * Telemetry Service — Phase 8
 *
 * Observability and operations: OpenTelemetry configuration,
 * collector config generation, redaction, runbooks, and
 * service catalog completeness.
 */

export class TelemetryService {
  /**
   * Generate OpenTelemetry Collector configuration
   */
  generateCollectorConfig(params: {
    serviceName: string;
    exporterEndpoint: string;
    redactionPatterns: RedactionRule[];
    samplingRate?: number;
  }): string {
    const redactionProcessors = params.redactionPatterns.map(
      (rule, _i) => `    redaction/${rule.name}:
      allow_all_keys: true
      blocked_values:
        - "${rule.pattern}"
      summary: debug`
    );

    return `# OpenTelemetry Collector Configuration
# Generated by Nebula for ${params.serviceName}

receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 5s
    send_batch_size: 1024

  memory_limiter:
    check_interval: 1s
    limit_mib: 512
    spike_limit_mib: 128

  resource:
    attributes:
      - key: service.name
        value: "${params.serviceName}"
        action: upsert
      - key: deployment.environment
        from_attribute: env
        action: upsert

  probabilistic_sampler:
    sampling_percentage: ${(params.samplingRate ?? 1.0) * 100}

  filter/health:
    error_mode: ignore
    traces:
      span:
        - 'attributes["http.route"] == "/health"'
        - 'attributes["http.route"] == "/health/live"'
        - 'attributes["http.route"] == "/health/ready"'

${redactionProcessors.length > 0 ? redactionProcessors.join("\n\n") : ""}

exporters:
  otlp:
    endpoint: "${params.exporterEndpoint}"
    tls:
      insecure: false

  debug:
    verbosity: basic

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [memory_limiter, filter/health, batch, resource, probabilistic_sampler]
      exporters: [otlp]

    metrics:
      receivers: [otlp]
      processors: [memory_limiter, batch, resource]
      exporters: [otlp]

    logs:
      receivers: [otlp]
      processors: [memory_limiter, batch, resource]
      exporters: [otlp]

  telemetry:
    logs:
      level: info
    metrics:
      address: 0.0.0.0:8888`;
  }

  /**
   * Generate per-stack instrumentation configuration
   */
  generateInstrumentationConfig(stackPack: string): InstrumentationConfig {
    const configs: Record<string, InstrumentationConfig> = {
      "typescript-react-nextjs": {
        language: "TypeScript",
        dependencies: [
          "@opentelemetry/sdk-node",
          "@opentelemetry/sdk-trace-node",
          "@opentelemetry/sdk-metrics",
          "@opentelemetry/exporter-trace-otlp-http",
          "@opentelemetry/exporter-metrics-otlp-http",
          "@opentelemetry/instrumentation-http",
          "@opentelemetry/instrumentation-express",
        ],
        setupCode: `// instrumentation.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';

const sdk = new NodeSDK({
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT + '/v1/traces',
  }),
  metricReader: new OTLPMetricExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT + '/v1/metrics',
  }),
  instrumentations: [new HttpInstrumentation()],
  serviceName: process.env.OTEL_SERVICE_NAME,
});

sdk.start();`,
      },
      "python-django": {
        language: "Python",
        dependencies: [
          "opentelemetry-api",
          "opentelemetry-sdk",
          "opentelemetry-instrumentation-django",
          "opentelemetry-exporter-otlp",
        ],
        setupCode: `# In manage.py or wsgi.py
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.instrumentation.django import DjangoInstrumentor

provider = TracerProvider()
processor = BatchSpanProcessor(OTLPSpanExporter())
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)
DjangoInstrumentor().instrument()`,
      },
      "rust-services": {
        language: "Rust",
        dependencies: [
          "tracing",
          "tracing-subscriber",
          "tracing-opentelemetry",
          "opentelemetry",
          "opentelemetry-otlp",
        ],
        setupCode: `// In main.rs
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

tracing_subscriber::registry()
    .with(tracing_subscriber::EnvFilter::new("info"))
    .with(tracing_subscriber::fmt::layer().json())
    .init();`,
      },
      "erlang-beam": {
        language: "Erlang",
        dependencies: ["opentelemetry_api", "opentelemetry", "opentelemetry_exporter"],
        setupCode: `% In sys.config
{opentelemetry, [
  {span_processor, batch},
  {traces_exporter, otlp}
]}.`,
      },
      "elixir-beam": {
        language: "Elixir",
        dependencies: ["opentelemetry_api", "opentelemetry", "opentelemetry_exporter"],
        setupCode: `# In config/runtime.exs
config :opentelemetry, :resource, service: %{name: "my-service"}
config :opentelemetry, traces_exporter: :otlp`,
      },
    };

    return configs[stackPack] || {
      language: "Unknown",
      dependencies: [],
      setupCode: "# No instrumentation config available for this stack pack",
    };
  }

  /**
   * Generate runbook entry from service metadata
   */
  generateRunbook(params: {
    serviceName: string;
    healthEndpoint: string;
    metricsPort: number;
    alerts: Array<{ name: string; condition: string; severity: string }>;
    commonIssues: Array<{ symptom: string; cause: string; resolution: string }>;
  }): string {
    const alertsTable = params.alerts
      .map((a) => `| ${a.name} | ${a.condition} | ${a.severity} |`)
      .join("\n");

    const issuesTable = params.commonIssues
      .map((i) => `| ${i.symptom} | ${i.cause} | ${i.resolution} |`)
      .join("\n");

    return `# ${params.serviceName} — Runbook

## Health Checks

- Liveness: \`${params.healthEndpoint}/live\`
- Readiness: \`${params.healthEndpoint}/ready\`
- Metrics: \`:${params.metricsPort}/metrics\`

## Alerts

| Alert | Condition | Severity |
|-------|-----------|----------|
${alertsTable || "| - | - | - |"}

## Common Issues

| Symptom | Likely Cause | Resolution |
|---------|-------------|------------|
${issuesTable || "| - | - | - |"}

## Scaling

- Horizontal: Increase replica count in deployment manifest
- Vertical: Adjust resource limits in deployment manifest

## Rollback

1. Identify the last good version: \`kubectl rollout history deployment/${params.serviceName}\`
2. Rollback: \`kubectl rollout undo deployment/${params.serviceName}\`
3. Or use Argo Rollouts: \`kubectl argo rollouts undo ${params.serviceName}\`

## Logs

\`\`\`bash
kubectl logs -f deployment/${params.serviceName} -n <namespace>
\`\`\`

## Traces

Query traces in your observability backend with:
- \`service.name = "${params.serviceName}"\`
`;
  }

  /**
   * Check service catalog completeness
   */
  checkCatalogCompleteness(entry: {
    name?: string;
    description?: string;
    owner?: string;
    lifecycle?: string;
    dependsOn?: string[];
    providesApis?: string[];
    runbook?: boolean;
    alerts?: boolean;
    dashboards?: boolean;
  }): CatalogCompletenessResult {
    const checks: Array<{ field: string; present: boolean; required: boolean }> = [
      { field: "name", present: !!entry.name, required: true },
      { field: "description", present: !!entry.description, required: true },
      { field: "owner", present: !!entry.owner, required: true },
      { field: "lifecycle", present: !!entry.lifecycle, required: true },
      { field: "dependencies", present: (entry.dependsOn?.length ?? 0) > 0, required: false },
      { field: "providedApis", present: (entry.providesApis?.length ?? 0) > 0, required: false },
      { field: "runbook", present: !!entry.runbook, required: true },
      { field: "alerts", present: !!entry.alerts, required: true },
      { field: "dashboards", present: !!entry.dashboards, required: false },
    ];

    const requiredMissing = checks.filter((c) => c.required && !c.present);
    const optionalMissing = checks.filter((c) => !c.required && !c.present);
    const totalPresent = checks.filter((c) => c.present).length;

    return {
      complete: requiredMissing.length === 0,
      completenessPercent: Math.round((totalPresent / checks.length) * 100),
      requiredMissing: requiredMissing.map((c) => c.field),
      optionalMissing: optionalMissing.map((c) => c.field),
      checks,
    };
  }
}

// ── Types ──

export interface RedactionRule {
  name: string;
  pattern: string;
  replacement: string;
}

export interface InstrumentationConfig {
  language: string;
  dependencies: string[];
  setupCode: string;
}

export interface CatalogCompletenessResult {
  complete: boolean;
  completenessPercent: number;
  requiredMissing: string[];
  optionalMissing: string[];
  checks: Array<{ field: string; present: boolean; required: boolean }>;
}
